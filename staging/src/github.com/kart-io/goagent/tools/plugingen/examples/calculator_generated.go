// Code generated by plugingen. DO NOT EDIT.
// A simple calculator plugin with type-safe boundaries
// Plugin: Calculator
// Version: v1.0.0

package calculator

import (
	"errors"
	"fmt"
	"time"
)

// CalculatorInput represents the plugin calculatorinput structure.
type CalculatorInput struct {
	// The operation to perform (add, subtract, multiply, divide)
	Operation string `json:"operation"`
	// First operand
	A float64 `json:"a"`
	// Second operand
	B float64 `json:"b"`
	// Number of decimal places for result
	Precision *int `json:"precision,omitempty"`
	// When the calculation was requested
	Timestamp time.Time `json:"timestamp,omitempty"`
}

// CalculatorOutput represents the plugin calculatoroutput structure.
type CalculatorOutput struct {
	// The calculation result
	Result float64 `json:"result"`
	// Error message if calculation failed
	Error *string `json:"error,omitempty"`
	// Time taken to perform the calculation
	Duration time.Duration `json:"duration,omitempty"`
}

// CalculatorInputFromMap converts a map[string]any to *CalculatorInput.
//
// This function performs type-safe conversion with validation for required fields.
func CalculatorInputFromMap(data map[string]any) (*CalculatorInput, error) {
	if data == nil {
		return nil, errors.New("input data is nil")
	}

	result := &CalculatorInput{}

	if val, ok := data["operation"]; ok {
		if typed, ok := val.(string); ok {
			result.Operation = typed
		} else {
			return nil, fmt.Errorf("field 'Operation' has wrong type, expected string")
		}
	}
	if result.Operation == "" {
		return nil, fmt.Errorf("required field 'operation' is missing")
	}
	if val, ok := data["a"]; ok {
		if typed, ok := val.(float64); ok {
			result.A = typed
		} else {
			return nil, fmt.Errorf("field 'A' has wrong type, expected float64")
		}
	}
	if result.A == 0 {
		return nil, fmt.Errorf("required field 'a' is missing")
	}
	if val, ok := data["b"]; ok {
		if typed, ok := val.(float64); ok {
			result.B = typed
		} else {
			return nil, fmt.Errorf("field 'B' has wrong type, expected float64")
		}
	}
	if result.B == 0 {
		return nil, fmt.Errorf("required field 'b' is missing")
	}
	if val, ok := data["precision"]; ok {
		if val != nil {
			if typed, ok := val.(int); ok {
				result.Precision = &typed
			}
		}
	}
	if val, ok := data["timestamp"]; ok {
		if typed, ok := val.(time.Time); ok {
			result.Timestamp = typed
		} else {
			return nil, fmt.Errorf("field 'Timestamp' has wrong type, expected time.Time")
		}
	}

	return result, nil
}

// CalculatorInputToMap converts a *CalculatorInput to map[string]any.
//
// This function performs type-safe serialization.
func CalculatorInputToMap(v *CalculatorInput) map[string]any {
	if v == nil {
		return nil
	}

	result := make(map[string]any)

	result["operation"] = v.Operation
	result["a"] = v.A
	result["b"] = v.B
	if v.Precision != nil {
		result["precision"] = *v.Precision
	}
	result["timestamp"] = v.Timestamp

	return result
}

// CalculatorOutputFromMap converts a map[string]any to *CalculatorOutput.
//
// This function performs type-safe conversion with validation for required fields.
func CalculatorOutputFromMap(data map[string]any) (*CalculatorOutput, error) {
	if data == nil {
		return nil, errors.New("input data is nil")
	}

	result := &CalculatorOutput{}

	if val, ok := data["result"]; ok {
		if typed, ok := val.(float64); ok {
			result.Result = typed
		} else {
			return nil, fmt.Errorf("field 'Result' has wrong type, expected float64")
		}
	}
	if result.Result == 0 {
		return nil, fmt.Errorf("required field 'result' is missing")
	}
	if val, ok := data["error"]; ok {
		if val != nil {
			if typed, ok := val.(string); ok {
				result.Error = &typed
			}
		}
	}
	if val, ok := data["duration"]; ok {
		if typed, ok := val.(time.Duration); ok {
			result.Duration = typed
		} else {
			return nil, fmt.Errorf("field 'Duration' has wrong type, expected time.Duration")
		}
	}

	return result, nil
}

// CalculatorOutputToMap converts a *CalculatorOutput to map[string]any.
//
// This function performs type-safe serialization.
func CalculatorOutputToMap(v *CalculatorOutput) map[string]any {
	if v == nil {
		return nil
	}

	result := make(map[string]any)

	result["result"] = v.Result
	if v.Error != nil {
		result["error"] = *v.Error
	}
	result["duration"] = v.Duration

	return result
}
